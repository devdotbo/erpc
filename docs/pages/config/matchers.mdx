---
description: Matchers provide a unified way to match and filter requests, responses, and upstreams throughout erpc...
---

import { Callout, Tabs, Tab } from 'nextra/components'

# Matchers

The **Matchers** component provides a unified way to match and filter requests throughout erpc based on various criteria like method, network, parameters, finality state, and empty responses.

## Overview

Matchers are used throughout erpc to make decisions about:
- **Request routing**: Send requests to specific upstreams or exclude certain upstreams
- **Response handling**: Accept or reject responses from upstreams
- **Caching**: Determine whether to cache responses
- **Authentication**: Control which methods require authentication
- **Failsafe policies**: Apply specific failsafe configurations to matching requests

## Configuration

Matchers are configured as part of failsafe policies:

<Tabs items={["yaml", "typescript"]} defaultIndex={0} storageKey="MatchersConfigTypeTabIndex">
  <Tabs.Tab>
```yaml filename="erpc.yaml"
networks:
  - architecture: evm
    evm:
      chainId: 1
    
    failsafe:
      # Match unfinalized eth_getLogs and apply specific policies
      - matchers:
          - method: "eth_getLogs"
            finality: unfinalized
            action: include
        retry:
          maxAttempts: 3
        timeout:
          duration: 30s
      
      # Match all other methods
      - matchers:
          - method: "*"
            action: include
        retry:
          maxAttempts: 2
        timeout:
          duration: 10s

upstreams:
  - id: archive-node
    endpoint: https://archive.example.com
    
    failsafe:
      # Only allow historical methods on this upstream
      - matchers:
          - method: "eth_getLogs|eth_getBlockByNumber|eth_getTransactionReceipt"
            action: include
          - method: "*"
            action: exclude
        timeout:
          duration: 60s
```
  </Tabs.Tab>
  <Tabs.Tab>
```ts filename="erpc.ts"
export default createConfig({
  projects: [{
    id: "main",
    networks: [{
      architecture: "evm",
      evm: { chainId: 1 },
      
      failsafe: [
        {
          matchers: [{
            method: "eth_getLogs",
            finality: "unfinalized",
            action: "include"
          }],
          retry: { maxAttempts: 3 },
          timeout: { duration: "30s" }
        }
      ]
    }]
  }]
});
```
  </Tabs.Tab>
</Tabs>

## Matcher Configuration

Each matcher can specify the following fields:

| Field | Type | Description |
|-------|------|-------------|
| `network` | string | Network ID pattern to match (supports wildcards) |
| `method` | string | RPC method pattern to match (supports wildcards) |
| `params` | array | Parameters to match (see param matching below) |
| `finality` | string | Data finality state: `finalized`, `unfinalized`, `realtime`, `unknown` |
| `empty` | string | Empty response behavior: `ignore`, `allow`, `only` |
| `action` | string | Action to take: `include` or `exclude` |

### Pattern Matching

All string fields support wildcard patterns using the same syntax as throughout erpc:

- `*` - matches any characters
- `|` - OR operator (e.g., `eth_getLogs|eth_getBlockByNumber`)
- `!` - NOT operator (e.g., `!debug_*`)

### Parameter Matching

The `params` field allows matching specific parameter values:

```yaml
matchers:
  # Match eth_getLogs with specific address
  - method: "eth_getLogs"
    params:
      - fromBlock: ">=0x100"
        toBlock: "<=0x200"
        address: "0x*"
    action: include
  
  # Match eth_call to specific contract
  - method: "eth_call"
    params:
      - to: "0x1234*"
    action: include
```

### Finality States

- `finalized`: Data from blocks that are confirmed as finalized
- `unfinalized`: Data from recent blocks that could still be reorged
- `realtime`: Data that changes with every block (e.g., gas price)
- `unknown`: When block finality cannot be determined

### Empty Response Behavior

- `ignore`: Do not match/cache empty responses (default)
- `allow`: Match/cache both empty and non-empty responses
- `only`: Only match/cache empty responses

## Use Cases

### 1. Route Unfinalized Data to Archive Nodes

```yaml
failsafe:
  - matchers:
      - method: "eth_getLogs"
        finality: unfinalized
        action: include
    # This config only applies to unfinalized eth_getLogs
    retry:
      maxAttempts: 5
    timeout:
      duration: 60s
```

### 2. Exclude Debug Methods from Light Nodes

```yaml
upstreams:
  - id: light-node
    failsafe:
      - matchers:
          - method: "debug_*|trace_*"
            action: exclude
        # These methods will not be sent to this upstream
```

### 3. Cache Only Non-Empty Responses

```yaml
cachePolicy:
  - network: "*"
    method: "eth_getTransactionReceipt"
    empty: ignore  # Don't cache null receipts
    finality: finalized
    ttl: 24h
```

### 4. Method-Specific Timeouts

```yaml
failsafe:
  - matchers:
      - method: "eth_getLogs"
        params:
          - fromBlock: "*"
            toBlock: "*"
        action: include
    timeout:
      duration: 120s  # Longer timeout for log queries
  
  - matchers:
      - method: "eth_blockNumber"
        action: include
    timeout:
      duration: 1s  # Quick timeout for simple queries
```

## Migration from Legacy Config

The old `matchMethod` and `matchFinality` fields are automatically converted to the new matchers format:

**Old format:**
```yaml
failsafe:
  - matchMethod: "eth_getLogs"
    matchFinality: ["unfinalized"]
    retry:
      maxAttempts: 3
```

**New format:**
```yaml
failsafe:
  - matchers:
      - method: "eth_getLogs"
        finality: unfinalized
        action: include
    retry:
      maxAttempts: 3
```

<Callout type="info">
  The legacy fields are deprecated but still supported for backward compatibility. They will be automatically converted to the new matchers format.
</Callout>

## Best Practices

1. **Order matters**: Matchers are evaluated in order. Place more specific matchers first.
2. **Use excludes sparingly**: It's often clearer to explicitly include what you want rather than exclude what you don't.
3. **Test your patterns**: Use the wildcard pattern syntax carefully, especially with complex patterns.
4. **Consider performance**: Complex parameter matching can add overhead, use it judiciously.

## Examples

### Complete Routing Example

```yaml
networks:
  - architecture: evm
    evm:
      chainId: 1
    
    # Network-level failsafe with matchers
    failsafe:
      # Historical queries get longer timeouts
      - matchers:
          - method: "eth_getLogs|eth_getBlockByNumber"
            finality: finalized
            action: include
        timeout:
          duration: 60s
        retry:
          maxAttempts: 3
      
      # Real-time data gets quick timeouts
      - matchers:
          - method: "*"
            finality: realtime
            action: include
        timeout:
          duration: 2s
        retry:
          maxAttempts: 1
      
      # Default for everything else
      - matchers:
          - method: "*"
            action: include
        timeout:
          duration: 10s

upstreams:
  # Archive node - only historical queries
  - id: archive-node
    endpoint: https://archive.example.com
    failsafe:
      - matchers:
          - method: "eth_getLogs|eth_getBlockByNumber|eth_getTransactionReceipt"
            finality: finalized
            action: include
          - method: "*"
            action: exclude
  
  # Fast node - only real-time queries
  - id: fast-node
    endpoint: https://fast.example.com
    failsafe:
      - matchers:
          - method: "eth_blockNumber|eth_gasPrice|eth_getBalance"
            finality: realtime
            action: include
          - method: "eth_sendRawTransaction"
            action: include
```

This configuration ensures:
- Historical queries only go to archive nodes with appropriate timeouts
- Real-time queries go to fast nodes with quick timeouts
- Each upstream only handles methods it's optimized for 